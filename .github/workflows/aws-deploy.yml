name: NewsArchivePro CI/CD

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

env:
  TREAT_WARNINGS_AS_ERRORS: true
  CI: true
  NODE_OPTIONS: "--max-old-space-size=4096"
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: newsarchivepro-backend
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [20.x]
      fail-fast: true

    outputs:
      build-success: ${{ steps.build-check.outputs.success }}
    
    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Set environment variables
        run: |
          echo "REACT_APP_SITE_URL=${{ secrets.REACT_APP_SITE_URL }}" >> $GITHUB_ENV
          echo "REACT_APP_APP_NAME=${{ secrets.REACT_APP_APP_NAME }}" >> $GITHUB_ENV
          echo "REACT_APP_VERSION=${{ secrets.REACT_APP_VERSION }}" >> $GITHUB_ENV
          echo "REACT_APP_API_GATEWAY_URL=${{ secrets.REACT_APP_API_GATEWAY_URL }}" >> $GITHUB_ENV
          echo "REACT_APP_AWS_REGION=${{ secrets.REACT_APP_AWS_REGION }}" >> $GITHUB_ENV
          echo "REACT_APP_AWS_CLOUDFRONT_DOMAIN=${{ secrets.REACT_APP_AWS_CLOUDFRONT_DOMAIN }}" >> $GITHUB_ENV
          echo "REACT_APP_MAX_FILE_SIZE=${{ secrets.REACT_APP_MAX_FILE_SIZE }}" >> $GITHUB_ENV
          echo "REACT_APP_MAX_BATCH_SIZE=${{ secrets.REACT_APP_MAX_BATCH_SIZE }}" >> $GITHUB_ENV
          echo "REACT_APP_ALLOWED_IMAGE_TYPES=${{ secrets.REACT_APP_ALLOWED_IMAGE_TYPES }}" >> $GITHUB_ENV
          echo "REACT_APP_SUPABASE_URL=${{ secrets.REACT_APP_SUPABASE_URL }}" >> $GITHUB_ENV
          echo "REACT_APP_SUPABASE_ANON_KEY=${{ secrets.REACT_APP_SUPABASE_ANON_KEY }}" >> $GITHUB_ENV
          echo "NODE_ENV=${{ secrets.NODE_ENV }}" >> $GITHUB_ENV
          echo "GENERATE_SOURCEMAP=false" >> $GITHUB_ENV

      - name: Verify required secrets
        run: |
          echo "üîç Verifying required environment variables..."
          missing_vars=""
          
          if [ -z "${{ secrets.REACT_APP_SITE_URL }}" ]; then missing_vars="$missing_vars REACT_APP_SITE_URL"; fi
          if [ -z "${{ secrets.REACT_APP_API_GATEWAY_URL }}" ]; then missing_vars="$missing_vars REACT_APP_API_GATEWAY_URL"; fi
          if [ -z "${{ secrets.REACT_APP_SUPABASE_URL }}" ]; then missing_vars="$missing_vars REACT_APP_SUPABASE_URL"; fi
          if [ -z "${{ secrets.REACT_APP_SUPABASE_ANON_KEY }}" ]; then missing_vars="$missing_vars REACT_APP_SUPABASE_ANON_KEY"; fi
          
          if [ -n "$missing_vars" ]; then
            echo "‚ùå Missing required secrets:$missing_vars"
            exit 1
          fi
          
          echo "‚úÖ All required environment variables are set"

      - name: Install Dependencies
        run: |
          echo "üì¶ Installing dependencies..."
          npm ci --prefer-offline --no-audit --progress=false
          
          if [ $? -ne 0 ]; then
            echo "‚ùå npm ci failed"
            exit 1
          fi
          
          echo "‚úÖ Dependencies installed successfully"

      - name: Security audit
        run: |
          echo "üîê Running security audit..."
          npm audit --audit-level high
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Security vulnerabilities found (high severity or above)"
            exit 1
          fi
          
          echo "‚úÖ No high-severity security vulnerabilities found"

      - name: Check for outdated packages
        run: |
          echo "üìã Checking for outdated packages..."
          npm outdated || true
          echo "‚ÑπÔ∏è Outdated package check completed (informational only)"

      - name: Lint code
        run: |
          echo "üßπ Running ESLint..."
          if [ -f ".eslintrc.json" ] || [ -f ".eslintrc.js" ] || [ -f "eslint.config.js" ]; then
            npm run lint 2>&1 | tee lint.log
            
            if [ $? -ne 0 ]; then
              echo "‚ùå ESLint failed - code quality issues found"
              cat lint.log
              exit 1
            fi
            
            echo "‚úÖ ESLint passed"
          else
            echo "‚ö†Ô∏è No ESLint configuration found, skipping lint check"
          fi

      - name: Type check (if TypeScript)
        run: |
          if [ -f "tsconfig.json" ]; then
            echo "üîç Running TypeScript type check..."
            npx tsc --noEmit
            
            if [ $? -ne 0 ]; then
              echo "‚ùå TypeScript type check failed"
              exit 1
            fi
            
            echo "‚úÖ TypeScript type check passed"
          else
            echo "‚ÑπÔ∏è No TypeScript configuration found, skipping type check"
          fi

      - name: Run tests
        run: |
          if npm run test --silent 2>/dev/null; then
            echo "üß™ Running tests..."
            npm test -- --coverage --watchAll=false --passWithNoTests
            
            if [ $? -ne 0 ]; then
              echo "‚ùå Tests failed"
              exit 1
            fi
            
            echo "‚úÖ All tests passed"
          else
            echo "‚ÑπÔ∏è No test script found, skipping tests"
          fi

      - name: Build
        run: |
          echo "üèóÔ∏è Building React application..."
          
          # Capture both stdout and stderr, and store exit code
          set +e
          npm run build 2>&1 | tee build.log
          BUILD_EXIT_CODE=$?
          set -e
          
          # Check build exit code first
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Build command failed with exit code $BUILD_EXIT_CODE"
            echo "Build output:"
            cat build.log
            exit 1
          fi
          
          # Check for any warnings in the build output
          if grep -i "warning\|warn" build.log; then
            echo "‚ö†Ô∏è Warnings found during build:"
            grep -i "warning\|warn" build.log
            echo "‚ùå Build failed due to warnings - treating warnings as errors"
            exit 1
          fi
          
          # Check for build errors
          if grep -i "error\|failed\|compilation failed" build.log; then
            echo "‚ùå Errors found during build:"
            grep -i "error\|failed\|compilation failed" build.log
            exit 1
          fi
          
          # Verify build directory exists and has content
          if [ ! -d "./build" ]; then
            echo "‚ùå Build directory not found - build failed"
            exit 1
          fi
          
          if [ -z "$(ls -A ./build)" ]; then
            echo "‚ùå Build directory is empty - build failed"
            exit 1
          fi
          
          # Check for essential files
          if [ ! -f "./build/index.html" ]; then
            echo "‚ùå index.html not found in build directory"
            exit 1
          fi
          
          echo "‚úÖ Build completed successfully without any warnings or errors"

      - name: Verify build integrity
        run: |
          echo "üîç Verifying build integrity..."
          
          # Check build size (should not be empty or too small)
          BUILD_SIZE=$(du -sh ./build | cut -f1)
          echo "Build size: $BUILD_SIZE"
          
          # Count files in build
          FILE_COUNT=$(find ./build -type f | wc -l)
          echo "Files in build: $FILE_COUNT"
          
          if [ $FILE_COUNT -lt 1 ]; then
            echo "‚ùå Build directory contains no files"
            exit 1
          fi
          
          # Check for common essential files
          ESSENTIAL_FILES="index.html"
          for file in $ESSENTIAL_FILES; do
            if [ ! -f "./build/$file" ]; then
              echo "‚ùå Essential file missing: $file"
              exit 1
            fi
          done
          
          echo "‚úÖ Build integrity verified"

      - name: Set build success
        id: build-check
        run: echo "success=true" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: build/
          retention-days: 1

  build-and-push-backend:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify backend directory exists
        run: |
          if [ ! -d "./backend/batch-ocr-app" ]; then
            echo "‚ùå Backend directory './backend/batch-ocr-app' not found"
            exit 1
          fi
          
          if [ ! -f "./backend/batch-ocr-app/Dockerfile" ]; then
            echo "‚ùå Dockerfile not found in './backend/batch-ocr-app/'"
            exit 1
          fi
          
          echo "‚úÖ Backend directory and Dockerfile verified"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          echo "üîç Verifying AWS credentials..."
          aws sts get-caller-identity
          
          if [ $? -ne 0 ]; then
            echo "‚ùå AWS credentials verification failed"
            exit 1
          fi
          
          echo "‚úÖ AWS credentials verified"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Verify ECR repository exists
        run: |
          echo "üîç Verifying ECR repository exists..."
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region ${{ secrets.AWS_REGION }}
          
          if [ $? -ne 0 ]; then
            echo "‚ùå ECR repository '$ECR_REPOSITORY' not found"
            echo "Please create the repository first:"
            echo "aws ecr create-repository --repository-name $ECR_REPOSITORY --region ${{ secrets.AWS_REGION }}"
            exit 1
          fi
          
          echo "‚úÖ ECR repository verified"

      - name: Build, tag, and push image to Amazon ECR
        working-directory: ./backend/batch-ocr-app
        run: |
          echo "üê≥ Building Docker image..."
          
          # Build with explicit error handling
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG . 2>&1 | tee docker_build.log
          
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "‚ùå Docker build failed"
            cat docker_build.log
            exit 1
          fi
          
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:ocr-batch .
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Docker build (ocr-batch tag) failed"
            exit 1
          fi
          
          echo "üì§ Pushing image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Docker push (with SHA tag) failed"
            exit 1
          fi
          
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:ocr-batch
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Docker push (ocr-batch tag) failed"
            exit 1
          fi
          
          echo "‚úÖ Image pushed successfully!"
          echo "üîÑ ECR-Batch automation will now automatically update AWS Batch job definitions"
          echo "üìã Monitor at: https://console.aws.amazon.com/cloudwatch/home?region=${{ secrets.AWS_REGION }}#dashboards:name=newsarchivepro-ocr-processing"
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Wait for ECR-Batch automation
        run: |
          echo "‚è≥ Waiting for ECR-Batch automation to complete..."
          echo "ü§ñ EventBridge will trigger Lambda function to update Batch job definitions"
          sleep 30
          
          # Check if Lambda function exists and get recent logs
          FUNCTION_NAME="newsarchivepro-ecr-batch-updater"
          if aws lambda get-function --function-name $FUNCTION_NAME --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚úÖ ECR-Batch automation Lambda function is deployed"
            
            # Get recent logs (last 2 minutes)
            echo "üìã Recent automation logs:"
            aws logs filter-log-events \
              --log-group-name "/aws/lambda/$FUNCTION_NAME" \
              --start-time $(date -d '2 minutes ago' +%s)000 \
              --region ${{ secrets.AWS_REGION }} \
              --query 'events[].message' \
              --output text || echo "No recent logs found (this is normal if automation hasn't run yet)"
          else
            echo "‚ö†Ô∏è ECR-Batch automation not deployed yet - run 'terraform apply' to enable automatic Batch updates"
          fi

      - name: Verify Batch job definition update
        run: |
          echo "üîç Verifying AWS Batch job definition was updated..."
          
          JOB_DEF_NAME="newsarchivepro-ocr-job-definition"
          
          # Get current Batch job definition image
          if aws batch describe-job-definitions --job-definition-name $JOB_DEF_NAME --status ACTIVE --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
            CURRENT_IMAGE=$(aws batch describe-job-definitions \
              --job-definition-name $JOB_DEF_NAME \
              --status ACTIVE \
              --region ${{ secrets.AWS_REGION }} \
              --query 'jobDefinitions[0].containerProperties.image' \
              --output text)
            
            CURRENT_REVISION=$(aws batch describe-job-definitions \
              --job-definition-name $JOB_DEF_NAME \
              --status ACTIVE \
              --region ${{ secrets.AWS_REGION }} \
              --query 'jobDefinitions[0].revision' \
              --output text)
            
            echo "üìã Current Batch job definition:"
            echo "   Revision: $CURRENT_REVISION"
            echo "   Image: $CURRENT_IMAGE"
            
            # Check if the image contains our latest tag or commit SHA
            if [[ "$CURRENT_IMAGE" == *"$IMAGE_TAG"* ]] || [[ "$CURRENT_IMAGE" == *"latest"* ]]; then
              echo "‚úÖ Batch job definition appears to be updated with latest image!"
            else
              echo "‚ö†Ô∏è Batch job definition may not be updated yet. This can take 1-2 minutes."
              echo "   Expected image to contain: $IMAGE_TAG or latest"
              echo "   Actual image: $CURRENT_IMAGE"
            fi
          else
            echo "‚ö†Ô∏è Batch job definition not found - may not be deployed yet"
            echo "   Run 'terraform apply' to deploy the complete infrastructure"
          fi

  deploy:
    runs-on: ubuntu-latest
    needs: [build-and-test, build-and-push-backend]
    if: github.ref == 'refs/heads/main' && needs.build-and-test.outputs.build-success == 'true'
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: build/

      - name: Verify downloaded artifacts
        run: |
          echo "üîç Verifying downloaded build artifacts..."
          
          if [ ! -d "./build" ]; then
            echo "‚ùå Build directory not found after download"
            exit 1
          fi
          
          if [ -z "$(ls -A ./build)" ]; then
            echo "‚ùå Build directory is empty after download"
            exit 1
          fi
          
          FILE_COUNT=$(find ./build -type f | wc -l)
          echo "Files in downloaded build: $FILE_COUNT"
          
          if [ $FILE_COUNT -lt 1 ]; then
            echo "‚ùå No files found in downloaded build"
            exit 1
          fi
          
          echo "‚úÖ Build artifacts verified"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify S3 bucket access
        run: |
          echo "üîç Verifying S3 bucket access..."
          aws s3 ls s3://caringalfrontend/ >/dev/null
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Cannot access S3 bucket 'caringalfrontend'"
            exit 1
          fi
          
          echo "‚úÖ S3 bucket access verified"

      - name: Deploy to S3
        run: |
          echo "üöÄ Starting deployment to S3..."
          echo "Bucket: caringalfrontend"
          echo "Path: frontend-build"
          echo "Region: ${{ secrets.AWS_REGION }}"
          
          echo "üìÅ Files to deploy:"
          find ./build -type f | head -10
          
          # Sync with explicit error handling
          aws s3 sync ./build s3://caringalfrontend/frontend-build --delete --exact-timestamps
          
          if [ $? -ne 0 ]; then
            echo "‚ùå S3 sync failed"
            exit 1
          fi
          
          echo "‚úÖ S3 deployment completed successfully"

      - name: Verify S3 deployment
        run: |
          echo "üîç Verifying S3 deployment..."
          
          # Check if index.html exists in S3
          aws s3 ls s3://caringalfrontend/frontend-build/index.html >/dev/null
          
          if [ $? -ne 0 ]; then
            echo "‚ùå index.html not found in S3 after deployment"
            exit 1
          fi
          
          echo "‚úÖ S3 deployment verified"

      - name: Invalidate CloudFront
        run: |
          echo "üîÑ Starting CloudFront invalidation..."
          echo "Distribution ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"
          
          if [ -z "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
            echo "‚ùå CLOUDFRONT_DISTRIBUTION_ID secret not set"
            exit 1
          fi
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*" \
            --output text \
            --query 'Invalidation.Id')
          
          if [ $? -ne 0 ]; then
            echo "‚ùå CloudFront invalidation failed"
            exit 1
          fi
          
          echo "Invalidation created with ID: $INVALIDATION_ID"
          echo "‚úÖ CloudFront invalidation initiated successfully"

  notify:
    runs-on: ubuntu-latest
    needs: [build-and-test, build-and-push-backend, deploy]
    if: always()
    
    steps:
      - name: Deployment Status
        run: |
          echo "üìä Final Deployment Status Report:"
          echo "=================================="
          
          if [ "${{ needs.build-and-test.result }}" = "success" ] && [ "${{ needs.build-and-push-backend.result }}" = "success" ] && [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "üéâ Full deployment completed successfully!"
            echo "‚úÖ Frontend build: SUCCESS"
            echo "‚úÖ Backend container: SUCCESS" 
            echo "‚úÖ Frontend deployment: SUCCESS"
          elif [ "${{ needs.build-and-test.result }}" = "failure" ]; then
            echo "‚ùå Frontend build failed - deployment skipped"
            echo "‚ùå Frontend build: FAILED"
            echo "‚è≠Ô∏è Backend container: SKIPPED"
            echo "‚è≠Ô∏è Frontend deployment: SKIPPED"
            exit 1
          elif [ "${{ needs.build-and-push-backend.result }}" = "failure" ]; then
            echo "‚ùå Backend container build failed"
            echo "‚úÖ Frontend build: SUCCESS"
            echo "‚ùå Backend container: FAILED"
            echo "‚ö†Ô∏è Frontend deployment: ${{ needs.deploy.result }}"
            exit 1
          elif [ "${{ needs.deploy.result }}" = "failure" ]; then
            echo "‚ùå Frontend deployment failed"
            echo "‚úÖ Frontend build: SUCCESS"
            echo "‚úÖ Backend container: SUCCESS"
            echo "‚ùå Frontend deployment: FAILED"
            exit 1
          elif [ "${{ needs.deploy.result }}" = "skipped" ]; then
            echo "‚è≠Ô∏è Deployment skipped (not main branch or build failed)"
            echo "‚ÑπÔ∏è This is normal for pull requests"
          else
            echo "‚ö†Ô∏è Unknown deployment status - check individual job results"
            echo "Frontend build: ${{ needs.build-and-test.result }}"
            echo "Backend container: ${{ needs.build-and-push-backend.result }}"
            echo "Frontend deployment: ${{ needs.deploy.result }}"
          fi